<!-- start:source.tmpl.hbs -->
<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="utf-8">
	<meta name="viewport" content="width=device-width">
		<title>index.js</title>
		<!--[if lt IE 9]>
		<script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
		<![endif]-->
		<link href="https://fonts.googleapis.com/css?family=PT+Mono" rel="stylesheet">
		<link type="text/css" rel="stylesheet" href="css/bootstrap.min.css">
		<link type="text/css" rel="stylesheet" href="css/prism.min.css">
		<link type="text/css" rel="stylesheet" href="css/template.min.css">
		<script type="text/javascript">
			window.TEMPLATE_OPTIONS = {"includeDate":true,"dateFormat":"Do MMM YYYY","systemName":"cli-driver","systemSummary":"like webdriver but for the command line","systemLogo":"","systemColor":"","navMembers":[{"kind":"class","title":"Classes","summary":"All documented classes."},{"kind":"external","title":"Externals","summary":"All documented external members."},{"kind":"global","title":"Globals","summary":"All documented globals."},{"kind":"mixin","title":"Mixins","summary":"All documented mixins."},{"kind":"interface","title":"Interfaces","summary":"All documented interfaces."},{"kind":"module","title":"Modules","summary":"All documented modules."},{"kind":"namespace","title":"Namespaces","summary":"All documented namespaces."},{"kind":"tutorial","title":"Tutorials","summary":"All available tutorials."}],"footer":"","copyright":"No copyright - knowledge shouldn't be a property","linenums":true,"collapseSymbols":true,"inverseNav":true,"inlineNav":false,"outputSourceFiles":true,"sourceRootPath":null,"disablePackagePath":true,"outputSourcePath":false,"showTableOfContents":true,"showAccessFilter":true,"analytics":null,"methodHeadingReturns":true,"sort":"linenum, longname, version, since","search":true,"favicon":null,"stylesheets":[],"scripts":[],"monospaceLinks":false,"cleverLinks":false};
			window.DOCLET_TOC_ENABLED = false;
			window.DOCLET_AFILTER_ENABLED = false;
		</script>
</head>
<body>
	<!-- start:navbar.hbs -->
	<header class="navbar navbar-default navbar-fixed-top navbar-inverse">
		<div class="container">
			<div class="navbar-header">
				<a class="navbar-brand" href="index.html">
					cli-driver
				</a>
				<!-- displayed on small devices -->
				<button class="navbar-toggle" type="button" data-toggle="collapse" data-target="#topNavigation">
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
					<span class="icon-bar"></span>
				</button>
			</div>
			<div class="navbar-collapse collapse" id="topNavigation">
				<ul class="nav navbar-nav">
							<li class="dropdown">
								<a href="list_class.html" class="dropdown-toggle" data-toggle="dropdown">Classes<b class="caret"></b></a>
								<ul class="dropdown-menu">
										<li><a href="CliDriver.html">CliDriver</a></li>
								</ul>
							</li>
							<li class="dropdown">
								<a href="list_tutorial.html" class="dropdown-toggle" data-toggle="dropdown">Tutorials<b class="caret"></b></a>
								<ul class="dropdown-menu">
										<li><a href="tutorial-sample_tutorial.html">Just An Example Tutorial</a></li>
								</ul>
							</li>
				</ul>
					<!-- start:lunr-search-navbar.hbs -->
					<form class="navbar-form navbar-right" role="search">
						<div class="input-group">
							<input type="text" class="form-control" placeholder="Search" id="lunr-search-input">
							<div class="input-group-btn">
								<button class="btn btn-default" id="lunr-search-submit">
									<i class="glyphicon glyphicon-search"></i>
								</button>
							</div>
						</div>
					</form>
					<!-- start:lunr-search-navbar.hbs -->		</div>
		</div>
	</header>
	<!-- end:navbar.hbs -->		<div class="page-header">
			<div class="container">
				<span class="kind">source</span>
				<h1><span class="name">index.js</span></h1>
			</div>
		</div>
	<div class="container content">
		<div class="row">
			<div class="col-md-12 main-content">
		<section class="source-section">
			<article></article>
			<pre class="prettyprint source language-javascript line-numbers"><code class="language-javascript">"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const os_1 = require("os");
const node_pty_1 = require("node-pty");
const events_1 = require("events");
const shell = require("shelljs");
const fs_1 = require("fs");
const path = require("path");
/**
 * Usage example:
 * ```js
 * const client = new Driver()
 * client.start({cwd: /home/sg/myproject})
 * client.enter('ls')
 * // now we wait until package.json is printed in stdout
 * const data = await client.waitForData(data => data.includes('package.json'))
 * ```
 */
class CliDriver extends events_1.EventEmitter {
    constructor() {
        super(...arguments);
        this.defaultOptions = {
            name: 'xterm-color',
            cols: 80,
            rows: 30,
            cwd: process.env.cwd,
            env: process.env,
            debug: false,
            notSilent: false
        };
        this.data = [];
        this.lastWrite = 0;
        // WAIT
        this._waitTimeout = 10000;
        this._waitInterval = 400;
    }
    start(options) {
        this.options = options || {};
        this.shellCommand = os_1.platform() === 'win32' ? 'powershell.exe' : 'bash';
        const ptyOptions = Object.assign({}, this.defaultOptions, this.options);
        this.ptyProcess = node_pty_1.spawn(this.shellCommand, [], ptyOptions);
        this.ptyProcess.on('data', data => {
            this.emit(CliDriver.EVENT_DATA, data);
        });
        this.on(CliDriver.EVENT_DATA, data => {
            this.handleData(data);
        });
        return Promise.resolve();
    }
    destroy() {
        this.ptyProcess.destroy();
        return Promise.resolve();
    }
    handleData(data) {
        this.data.push({
            data,
            timestamp: Date.now()
        });
        if (this.options.notSilent) {
            process.stdout.write(data);
        }
    }
    // WRITE
    /**
     * Will write given text and then press ENTER
     * @param input the string to enter
     */
    async enter(input) {
        // console.log('ENTER: ', input)
        return this.write(input + '\r');
    }
    /**
     * @param str writes given text. Notice that this won't submit ENTER. For that you need to append "\r" or use @link enter
     */
    async write(str) {
        this.lastWrite = Date.now(); // TODO: all the performance magic should happen here - we should acomodate all the data
        this.ptyProcess.write(str);
        return this.promiseResolve();
    }
    // READ
    /**
     * get current data from last time enter() was issued
     * @param {number} lastWrite Optional get data from given time
     */
    getDataFromLastWrite(lastWrite = this.lastWrite) {
        // make this more performant but storing last index and last data returned index we know is less than this.lastwrite so we dont have to iterate all the array and concatenate all again
        return this.getDataFromTimestamp(this.lastWrite);
    }
    /**
     * @param {number} timestamp Optional get data from given time
     */
    getDataFromTimestamp(timestamp) {
        // make this more performant but storing last index and last data returned index we know is less than this.lastwrite so we dont have to iterate all the array and concatenate all again
        let i = 0;
        for (; i &lt; this.data.length; i++) {
            if (this.data[i].timestamp > timestamp) {
                break;
            }
        }
        let dataFrom = '';
        for (; i &lt; this.data.length; i++) {
            dataFrom += this.data[i].data;
        }
        return Promise.resolve(dataFrom);
    }
    getAllData() {
        // TODO: make it performant by storing all data and only concatenate from allDataLastIndex
        let ad = '';
        this.data.forEach(d => ad += d.data);
        return Promise.resolve(ad);
    }
    /**
     * for how long wait* function will wait until it return a rejected promise
     * @type {number}
     */
    set waitTimeout(t) {
        this._waitTimeout = t;
    }
    /**
     * how periodically wait* functions will poll to check given predicate
     * @type {number}
     */
    set waitInterval(t) {
        this._waitInterval = t;
    }
    /**
     * will wait until new data matches given predicate. If not predicate is given will return the next data chunk that comes.
     * @param {WaitPredicate | string} predicate condition stdout must comply with in other to stop waiting for. If none it will wait until next data chunk is received. If function that's the predicate function the data must comply with. If string, the predicate will be that new data contains this string
     * @param {number} [timeout] wait timeout in ms
     * @param {number} [interval] wait interval in ms
     * @param {number} [afterTimestamp] if provided it will ork with data after that given timestamp. By default this timestamp is the last write()'s
     * @return {Promise&lt;String>} resolved with the matched data or rejected if no data comply with predicate before timeout
     */
    waitForData(predicate, timeout = this._waitTimeout, interval = this._waitInterval, afterTimestamp = this.lastWrite) {
        // console.log('waitForData')
        let intervalId;
        const realPredicate = typeof predicate === 'string' ? (data) => data.includes(predicate) : predicate;
        const checkData = async (resolve) => {
            const data = await this.getDataFromTimestamp(afterTimestamp);
            if (realPredicate(data)) {
                // console.log('***MATCH***', predicate.toString(), JSON.stringify({ data }), '***MATCH***')
                clearInterval(intervalId);
                this.promiseResolve(data, resolve);
            }
            else {
                // console.log('**NO MATCH**', predicate.toString(), JSON.stringify({ data }), '**NO MATCH**')
                setTimeout(async () => {
                    checkData(resolve);
                }, timeout);
            }
        };
        // TODO: make me faster please!
        return new Promise((resolve, reject) => {
            if (predicate) {
                intervalId = setInterval(async () => {
                    checkData(resolve);
                }, interval);
                setTimeout(() => {
                    this.promiseReject('TIMEOUT, use CmdClient.waitTimeout property to increase it ?', reject);
                }, timeout);
            }
            else {
                this.once(CliDriver.EVENT_DATA, data => resolve(data));
            }
        });
    }
    /**
     *
     * @param {WaitPredicate | string } predicate same as @link{waitForData}
     * @param {string} commandToEnter same as @link{write}
     * @param {number}[timeout] same as @link{waitForData}
     * @param {number}[interval] same as @link{waitForData}
     * @param {number}[afterTimestamp] same as @link{waitForData}
     * @return {Promise&lt;string>} same as @link{waitForData}
     */
    waitForDataAndEnter(predicate, commandToEnter, timeout = this._waitTimeout, interval = this._waitInterval, afterTimestamp = this.lastWrite) {
        // console.log('waitForDataAndEnter')
        return new Promise((resolve, reject) => {
            this.waitForData(predicate, timeout, interval, afterTimestamp).then(async (data) => {
                await this.enter(commandToEnter);
                this.promiseResolve(data, resolve);
            }).catch(ex => {
                this.promiseReject(ex, reject);
            });
        });
    }
    // MISC
    dumpState() {
        return Promise.resolve({
            data: this.data,
            lastWrite: this.lastWrite,
            shellCommand: this.shellCommand
        });
    }
    debug(text) {
        return new Promise(resolve => {
            if (typeof this.options.debug === 'string') {
                shell.mkdir('-p', path.dirname(this.options.debug));
                fs_1.appendFile(this.options.debug, text, () => {
                    resolve();
                });
            }
            else if (this.options.debug) {
                console.log(text);
                resolve();
            }
            else {
                resolve();
            }
        });
    }
    promiseResolve(resolveWith, resolve) {
        if (resolve) {
            resolve(resolveWith);
        }
        return Promise.resolve(resolveWith);
    }
    async promiseReject(rejectWith, reject) {
        await this.debug(`promise rejected, printing state::

    ${JSON.stringify(await this.dumpState())}

    `);
        if (reject) {
            reject(rejectWith);
        }
        return Promise.reject(rejectWith);
    }
    async wait(ms) {
        return new Promise(resolve => {
            setTimeout(() => {
                resolve();
            }, ms);
        });
    }
}
CliDriver.EVENT_DATA = 'pty-data';
exports.default = CliDriver;
</code></pre>
		</section>
			</div>
		</div>
	</div>
	<footer>
				<div class="copyright">No copyright - knowledge shouldn&#x27;t be a property</div>
			<div class="generated-by">Documentation generated by <a href="https://github.com/jsdoc3/jsdoc">JSDoc 3.5.5</a> on 9th Apr 2018 using the <a href="https://github.com/steveush/foodoc">FooDoc template</a>.</div>
	</footer>
	<script src="js/jquery.min.js"></script>
	<script src="js/bootstrap.min.js"></script>
	<script src="js/clipboard.min.js"></script>
	<script src="js/prism.min.js"></script>
	<script src="js/template.min.js"></script>
		<!-- start:lunr-search-modal.hbs -->
		<div class="modal fade" id="lunr-search-modal">
			<div class="modal-dialog">
				<div class="modal-content">
					<div class="modal-header">
						<button type="button" class="close" data-dismiss="modal" aria-label="Close"><span aria-hidden="true">&times;</span></button>
						<h4 class="modal-title">Search results</h4>
					</div>
					<div class="modal-body" id="lunr-search-body">
					</div>
					<div class="modal-footer" id="lunr-search-footer">
						<button type="button" class="btn btn-default" data-dismiss="modal">Close</button>
					</div>
				</div><!-- /.modal-content -->
			</div><!-- /.modal-dialog -->
		</div>
		<!-- end:lunr-search-modal.hbs -->		<script src="js/lunr.min.js"></script>
	
</body>
</html>
<!-- end:source.tmpl.hbs -->